/**
* This file was automatically generated by @octalmage/terra-cosmwasm-typescript-gen@0.1.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @octalmage/terra-cosmwasm-typescript-gen generate command to regenerate this file.
*/

import { LCDClient, Coins, Wallet, MsgExecuteContract, TxInfo, WaitTxBroadcastResult } from "@terra-money/terra.js";
import { ConnectedWallet } from "@terra-money/wallet-provider";
function isConnectedWallet(x: Wallet | ConnectedWallet): x is ConnectedWallet {
  return typeof (x as Wallet).key === "undefined";
};
async function waitForInclusionInBlock(lcd: LCDClient, txHash: string): Promise<TxInfo | undefined> {
  let res;
  for (let i = 0; i <= 50; i++) {
    try {
      res = await lcd.tx.txInfo(txHash);
    } catch (error) {
      // NOOP
    }
      
    if (res) {
      break;
    }
      
    await new Promise((resolve) => setTimeout(resolve, 500));
  }
      
  return res;
};
export type ExecuteMsg = {
  create_post: {
    body: string;
    image: string;
    title: string;
    [k: string]: unknown;
  };
} | {
  toggle_upvote_post: {
    index: number;
    [k: string]: unknown;
  };
};
export type Addr = string;
export interface InstantiateMsg {
  posts: Post[];
  [k: string]: unknown;
}
export interface Post {
  body: string;
  image: string;
  owner: Addr;
  title: string;
  upvotes: string[];
  [k: string]: unknown;
}
export interface PostsByAddressResponse {
  posts: Post[];
  [k: string]: unknown;
}
export interface PostsResponse {
  posts: Post[];
  [k: string]: unknown;
}
export type QueryMsg = {
  get_posts: {
    [k: string]: unknown;
  };
} | {
  get_posts_by_address: {
    addr: Addr;
    [k: string]: unknown;
  };
};
export interface State {
  owner: Addr;
  posts: Post[];
  [k: string]: unknown;
}
export interface BoardReadOnlyInterface {
  contractAddress: string;
  getPosts: () => Promise<PostsResponse>;
  getPostsByAddress: ({
    addr
  }: {
    addr: string;
  }) => Promise<PostsByAddressResponse>;
}
export class BoardQueryClient implements BoardReadOnlyInterface {
  client: LCDClient;
  contractAddress: string;

  constructor(client: LCDClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getPosts = this.getPosts.bind(this);
    this.getPostsByAddress = this.getPostsByAddress.bind(this);
  }

  getPosts = async (): Promise<PostsResponse> => {
    return this.client.wasm.contractQuery(this.contractAddress, {
      get_posts: {}
    });
  };
  getPostsByAddress = async ({
    addr
  }: {
    addr: string;
  }): Promise<PostsByAddressResponse> => {
    return this.client.wasm.contractQuery(this.contractAddress, {
      get_posts_by_address: {
        addr
      }
    });
  };
}
export interface BoardInterface extends BoardReadOnlyInterface {
  contractAddress: string;
  createPost: ({
    body,
    image,
    title
  }: {
    body: string;
    image: string;
    title: string;
  }, funds?: Coins) => Promise<any>;
  toggleUpvotePost: ({
    index
  }: {
    index: number;
  }, funds?: Coins) => Promise<any>;
}
export class BoardClient extends BoardQueryClient implements BoardInterface {
  client: LCDClient;
  wallet: Wallet | ConnectedWallet;
  contractAddress: string;

  constructor(client: LCDClient, wallet: Wallet | ConnectedWallet, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.wallet = wallet;
    this.contractAddress = contractAddress;
    this.createPost = this.createPost.bind(this);
    this.toggleUpvotePost = this.toggleUpvotePost.bind(this);
  }

  createPost = async ({
    body,
    image,
    title
  }: {
    body: string;
    image: string;
    title: string;
  }, funds?: Coins): Promise<WaitTxBroadcastResult | TxInfo | undefined> => {
    const senderAddress = isConnectedWallet(this.wallet) ? this.wallet.walletAddress : this.wallet.key.accAddress;
    const execMsg = new MsgExecuteContract(senderAddress, this.contractAddress, {
      create_post: {
        body,
        image,
        title
      }
    }, funds);

    if (isConnectedWallet(this.wallet)) {
      const tx = await this.wallet.post({
        msgs: [execMsg]
      });
      return waitForInclusionInBlock(this.client, tx.result.txhash);
    } else {
      const execTx = await this.wallet.createAndSignTx({
        msgs: [execMsg]
      });
      return this.client.tx.broadcast(execTx);
    }
  };
  toggleUpvotePost = async ({
    index
  }: {
    index: number;
  }, funds?: Coins): Promise<WaitTxBroadcastResult | TxInfo | undefined> => {
    const senderAddress = isConnectedWallet(this.wallet) ? this.wallet.walletAddress : this.wallet.key.accAddress;
    const execMsg = new MsgExecuteContract(senderAddress, this.contractAddress, {
      toggle_upvote_post: {
        index
      }
    }, funds);

    if (isConnectedWallet(this.wallet)) {
      const tx = await this.wallet.post({
        msgs: [execMsg]
      });
      return waitForInclusionInBlock(this.client, tx.result.txhash);
    } else {
      const execTx = await this.wallet.createAndSignTx({
        msgs: [execMsg]
      });
      return this.client.tx.broadcast(execTx);
    }
  };
}